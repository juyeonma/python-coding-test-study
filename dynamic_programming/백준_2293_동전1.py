'''
# 백준_2293_동전 1. 골드 5. 풀이: 23.05.18 -> 실패

# How to
- 동전을 탐색하며, 이 동전으로 목표금액을 만들었을때 경우의 수를 dp에 입력한다.
- 점화식: dp[k] = dp[k] + dp[k-n]
- 예: 동전 2원이고, 목표금액 5원일때
    - 동전 1원으로 목표금액 5원을 만들 수 있음
    - 목표금액 3원(=5-2)의 경우의 수에 2원을 추가하기만 하면 5원을 만들 수 있음
    - 즉 기존에 dp[5]가 존재하고, 여기에 dp[5-2]=dp[3]을 누적해 dp[5]를 갱신한다.


# Review
- 참고: https://bitwise.tistory.com/504
- 문제를 보자마자 조합을 떠올렸다. 그런데 시간 제한이 타이트해서, 조합은 버렸다.
- 직접 동전을 적어가면서 점화식을 고민했지만, 실패하고 검색했다.
    - 여태껏 목표금액을 기준으로 동전을 더했는데, 동전을 기준으로 목표금액과의 차를 dp 테이블에서 찾는게 충격이었다.
- DP는 점화식만 제대로 세우면 코드 구현은 매우 쉽다지만, 그 점화식을 생각하기 너무..어렵다..
- 자꾸 실패해서 검색하니까 슬프다..    
'''

# 검색한 Code
import sys
input = sys.stdin.readline

n, k = map(int, input().split())
coins = [int(input()) for _ in range(n)]
dp = [0] * (k+1)
dp[0] = 1

for i in coins:
    for j in range(i, k+1):
        dp[j] += dp[j-i]
        
print(dp[k])


'''
# Result
풀이 시간: 실패
메모리: 31256 KB
시간: 172 ms
코드 길이: 232 B
'''