'''
# 백준_15989_1, 2, 3 더하기 4. 실버 1. 풀이: 23.08.03

# How to
- 더해서 n을 만드는건 n-1, n-2, n-3을 만드는 합에 각각 1, 2, 3을 더하는 것과 같다.
    - 1: 1+1+1...+1. 즉 경우의 수는 1개뿐
    - 2: 1+1...+2, 또는 1+1+2+2+...+2. 즉 n-2의 합에 2를 더한 것 뿐.
    - 3: 1+1...+3, 또는 1+1+2+3+...+3. 즉 n-3의 합에 3를 더한 것 뿐.
    
- 근데 중복을 피하기 위해(순서만 다른건 같은 것으로 친다)
    - n-i를 할 때, 끝자리가 i보다 작거나 같은 합의 경우만 센다.

    
## 1. dp에 인덱스 1, 2, 3 매번 갱신하기: 시간초과
- 점화식:
n <= 3 일때,
n을 만들기 위한 경우의 수: n

n > 3 이라면, 
dp[n] = [0, 1, sum(dp[n-2][:3]), sum(dp[n-3])]
n을 만들기 위한 경우의 수: sum(dp[n])


## 2. 2, 3만 세기, 먼저 dp 만들기: 성공
- 1의 시간초과 이유:
    - 인덱스 0과 1이 항상 같아서 불필요한 메모리를 차지한다.
    - 매번 dp를 구하기 때문에 중복된다.
- 그래서,
    - 2와 3만 dp에 담아줬다. 이때 매번 1의 경우의 수를 더해야하기 때문에, 먼저 dp를 [1, 1] 로 초기화 했다.
    - 최대 입력값(10,000)까지 dp를 다 만든후 필요한 입력값만 찾았다.


## 예시
n=1: 1
n=2: 1+1, 2
n=3: 1+1+1, 1+2, 3

n=4: 1+1+1+1, 1+1+2, 1+3, 2+2
n=5: 1+1+1+1+1, 1+1+1+2, 1+1+3, 1+2+2, 2+3


# Review
- 풀이 시간: 20분
- 현재 dp가 길이 2의 리스트인데, 그냥 하나의 값으로 나타낸다면 더 시간이 단축될듯 하다.
'''

# Code
# 1. dp에 인덱스 1, 2, 3 매번 갱신하기: 시간초과
## 메모리:  KB, 시간:  ms
def solve():
    n = int(input())
    if n <= 3:
        return n
    
    dp = [[0, 0, 0, 0] for _ in range(n+1)]
    dp[1] = [0, 1, 0, 0]
    dp[2] = [0, 1, 1, 0]
    dp[3] = [0, 1, 1, 1]
    
    for i in range(4, n+1):
        dp[i] = [0, 1, sum(dp[i-2][:3]), sum(dp[i-3])]

    return sum(dp[n])
    
for _ in range(int(input())):
    print(solve())


# 2. 2, 3만 세기, 먼저 dp 만들기: 성공
## 메모리: 32276 KB, 시간: 84 ms
dp = [[1, 1] for _ in range(10_001)]
dp[1] = [0, 0]
dp[2] = [1, 0]
dp[3] = [1, 1]
dp[4] = [2, 1]

for i in range(5, 10_001):
    dp[i][0] += dp[i-2][0]
    dp[i][1] += sum(dp[i-3])
    
for _ in range(int(input())):
    print(sum(dp[int(input())])+1)
    