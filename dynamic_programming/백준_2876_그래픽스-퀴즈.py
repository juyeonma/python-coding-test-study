'''
# 백준_2876_그래픽스 퀴즈. 실버 2. 풀이: 23.05.23

# How to
- 연속된 최댓값을 구하는게 포인트
- 연속된 갯수를 기록할 list, 최댓값을 기록할 list를 각각 만든다.
- 연속된 등급이라면, +1
- 연속되지 않았다면, 기존의 연속기록을 최댓값 갱신하고, 1 기록

## 반례
- 연속된 수와 최댓값을 별도로 기록하지 않는다면, 이 반례에서 막힐 수 있다.
5
2 2
2 4
1 4
2 3
2 5
답: 2 2


# Review
- 우선 문제 이해를 못했다. 문제 이해만 30분 한듯.. 문제가 너무 애매하게 적혀있었다.
    - 특히 'N개의 책상이 한 줄로 늘어서 있다'는게 가로인지 세로인지 헷갈렸다.
- 반례를 찾느라 고생했다. 
    - 처음에는 dp[j] = max(dp[j], 1) 라고 기록했는데, 이게 최댓값을 갱신시키지 못했다.
    - 결국 최댓값을 기록할 별도의 리스트를 만들었다.
- 모든 책상을 살핀 후에 다시 최댓값 갱신을 해야했다. 이걸 빼먹어서 또 반례를 찾고..휴
- 문제를 잘못 골랐다..ㅎ... 
    - 다 풀고나서 더 효율적인 코드가 궁금해서 맞힌 사람을 눌렀더니, 내가 1등...?
    - 구글링을 하니, 몇개만 나오더라..
    - 어쩐지 문제도 이상하더라..ㅠㅠ
'''

# Code
import sys
input = sys.stdin.readline

n = int(input())

# 현재 연속된 갯수를 기록: 등급은 1~5까지 존재
dp = [0] * 6
# 최댓값 저장
result = [0] * 6

# 첫번째 책상의 값 저장
c, d = map(int, input().split())
for i in {c, d}:
    dp[i] += 1
    result[i] += 1

# 두번째부터 차례대로 살피며, 연속된 값 기록 및 최댓값 갱신
for _ in range(n-1):
    a, b = map(int, input().split())
    # 두명의 학생이 같은 등급일 수도 있으므로, set 사용
    for j in {a, b}:
        # 연속된 등급이라면, +1
        if j in (c, d):
            dp[j] += 1
        # 연속되지 않았다면, 기존의 연속기록을 최댓값 갱신하고, 1 기록
        else:
            result[j] = max(result[j], dp[j])
            dp[j] = 1
  
    c, d = a, b

# 최댓값 갱신
for i in range(6):
    result[i] = max(result[i], dp[i]) 

# 최댓값과 그때의 인덱스(즉, 등급) 출력
print(max(result), result.index(max(result)), sep=' ')


'''
# Result
풀이 시간: 1시간 15분
메모리: 31256 KB
시간: 184 ms
코드 길이: 540 B
'''