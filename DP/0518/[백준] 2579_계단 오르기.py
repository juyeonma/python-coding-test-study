# 1. 테이블 정의
# d[i] = d[i]까지 도달했을 때의 점수의 최댓값
# 2. 점화식
# 3. 초기값
# d[i-1]의 최대값을 통해서 d[i]를 구할 수 없다.(아래에 구할 수있는 방법을 찾았다. dp를 푸는 방법은 다른 알고리즘에 비해 다양한 것 같다.) 왜나하면 문제에 한 번에 한계단이나 두계단식 올라야 한다는 조건이 있기 때문이다.
# 만약 d[i-1]에 최대값이 들어있지만 연속해서 두계단을 밟은 상태라면  그 값을 이용해서 d[i]를 구할 수 없다.

# 올바른 사고 과정
# 이전이전의 연속 두계단을 밟고 한계단을 뛰어넘고 해당 계단을 밟는 경우, 이전계단을 밝고 현재계단을 밟는 경우
# 위 두가지의 경우 중 하나가 최대값이 되고 무엇이 최대값이 될지는 모르기때문에 모두 구하면서 넘어가야한다. >> 그래야 점화식을 세울 수 있다.
# d[i][1] = max(d[i-2][1],d[i-2][2]) + s[i] >> d[i-2]에서 한계단을 밟는 경우와 두계단을 모두 밟는 경우 중 무엇이 최대가 될지 모르므로 둘중에 최대값
# d[i][2] = d[i-1][1]+ s[i] >> 현재연속 두계단을 밟은 상태라면 이전에 값을 무조건 밟아야 하기 때문에 d[i-1][1] 밖에 될 수 있는 것이 없다.

# 그러므로 d[i][1](연속 1계단) = max(d[i-2][1]+s[i],d[i-2][2]+s[i])
# d[i][2](연속 2계단) = d[i-1][1]+s[i]

# dp 역시 어렵다.. 사고과정이 너무 어렵다. 재귀가 생각나는 알고리즘이다. 이전의 상태에 연연하지 말고 이전에 상태는 이미 다 구해졌다고 생각하기!

n = int(input())
s = [int(input()) for _ in range(n)]
d = [[s[0],0]]+[[0,0] for _ in range(n-1)]

if n>1:
    d[1][0]=s[1]
    d[1][1]=s[0]+s[1]

for i in range(2,n):
    d[i][0] = max(d[i-2][0],d[i-2][1]) + s[i]
    d[i][1] = d[i-1][0]+s[i]

print(max(d[n-1]))


# 1. 테이블 정의
# d[i] = i까지 왔을 때의 점수 최대값, i는 밟은 상태여야함
# 2. 점화식
# d[i]는 i-1을 밟고 오는 경우, i-1을 밟지 않고 오는 경우 중 최대값 구해야한다
# i-1을 밟지 않는 경우에서 구할 수 있는 최대값은 d[i-2]+s[i] 이다  왜냐하면 d에는 최대값이 담기고 i-1을 밟지 않는 경우에서는 i-2를 밟는 경우가 가장 최대값이기 때문이다.
# i-1을 밟는 경우는 d[i-1]+s[i]가 아니다 왜냐하면 d[i-1]이 최대라고 해도 i-2도 밟은 상태라면 i는 밟을 수 없기 때문이다.
# 그렇다면 i-1을 밟는 경우는 d[i-1]이 아니라 s[i-1]로 더해준다. 그러면 i-1과 i를 밟은 상태이기때문에 d[i-2]도 사용할 수없다. 
# 이렇게 되면 i-2는 밟지 않은 상태가 되기때문에 i-3까지의 최대값을 더해주면 된다.
# 그러므로 d[i] = d[i-3] + s[i-1]+s[i]
# 즉 d[i] = max(d[i-3]+s[i-1], d[i-2]) + s[i] 가 된다.
# 초기값
# n 이 3이상이라면 3까지 구해야한다.
n = int(input())
s = [int(input()) for _ in range(n)]
d = [0]*n

for i in range(n):
    if i<2:
        d[i]=sum(s[0:i+1])
    elif i==2:
        d[i]=max(s[0]+s[2],s[1]+s[2])
    else:
        d[i]=max(d[i-3]+s[i-1], d[i-2]) + s[i]
print(d[n-1])


# 테이블정의
# d[i] = i까지의 계단 중에 밟지 않는 계단 점수의 최솟값. 단, i번째는 밟지 않아야함
# 점화식
# i-1을 안밟는 경우 i-1을 밟는 경우
# i-1을 안밟는 경우는 d[i-1]+s[i]이다
# i-1을 밟는 경우는 i-2까지 밟는경우와 i-2는 밟지 않는 경우로 나뉜다
# 전자는  d[i-3]+s[i]    후자는 d[i-2]+s[i] 
# 여기서는 
