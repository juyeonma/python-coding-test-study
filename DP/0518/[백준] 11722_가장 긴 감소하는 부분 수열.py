# n이 1000으로 n^2이 되어도 백만정도밖에 안된다
# 테이블 정의
# d[i]= 처음부터 i위치까지 감소하는 수열의 최대길이
# 점화식
# i이전의 arr 중 i와 가장 가까우면서 i보다 큰 값 찾기 >> 해당위치의 d[k]+1

# 처음엔 감이 안잡혀서 못풀고있다가 n을봤더니 n^2까지 가능해서 완탐느낌을 가져간 dp인가하고 풀었다.
# dp는 그냥 for문 하나로 돌면서 차례대로 구해나가는 거라고만 샏각했는데.... 어느 유형이든 고정관념을 가지고 있구나 싶었다

# 완전 스스로 푼 건아니고 자꾸 틀려서 반례를 하나 보고 풀었다. 원래는 두번째 for문에서 거꾸로 돌면서 arr[i]보다 큰 값이 있으면 바로 1을 더하고 break를 넣었지만 그게 최소라는 걸 보장할 수 없기에 break를 지우고 for문을 다돌면서 최대값을 구하는 방식으로 풀었따.
# 6
# 4 6 3 2 4 1
# 이런케이스에서 막혔었다.

n = int(input())
arr= list(map(int,input().split()))
d =[1]*n
for i in range(1,n): # dp배열을 채울 for 문
    for j in range(i): # 입력값을 돌면서 arr[i]보다 큰 값을 찾을 배열
        if arr[j]>arr[i]:
            d[i]=max(d[i],d[j]+1) # 다돌면서 최대값 찾기
print(max(d))