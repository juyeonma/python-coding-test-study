# 문제가 이해가 안가서 이해하는데만 15분정도 걸린것같다. 이해력이 부족한건가 싶어서 자괴감이 왔다
# 그리고 아이디어는 5분정도 걸려서 떠올렸는데 헤갈리는 부분이 있어서 코드를 오래 작성했다.
# dp = 점화식 이라는 생각을 가지고 있었으면 못풀지 않았을까 싶다. dp는 작은문제를 통한 큰 문제 해결!
# 아이디어를 떠올리기는 했지만 뭔가 운좋게 떠올린 느낌이다
# N이 십만이라 N^2으로는 풀 수 없고 N으로 풀어야 된다는 생각이 들었다.
# 처음엔 1번책상 2번책상 비교하고 13, 14 ... 23 24... 이런식으로 하려고 했지만 이것도 n^2이라서 다른 방법이 필요했다.
# 어떻게 생각하게된 줄은 모르겠지만 2중배열로 테이블을 만들어 보자는 생각이 들었고, 연속적인 책상에서 같은 숫자를 갖고 있어야 한다는 점에서
# 책상순서대로 번호를 체크했고 각 그레이드마다 연속적인 체크가 있는 부분을 고르면 된다고 생각이 들어 이 아이디어로 풀었다.
# 그러면 시간복잡도는 5 * 100000 으로 최대 오십만정도로 아주 넉넉하다

# 풀긴 풀었지만 완전히 이해한 느낌이 아니다. 나중에 다시 풀어봐야겠다. 

# 4
# 2 1
# 3 2
# 5 3
# 2 5
#   1 2 3 4 5   그레이드
# 0 1 1 0 0 0
# 0 0 1 1 0 0
# 0 0 0 1 0 1
# 0 0 1 0 0 1
#그레이드 별로 내려가면서 배열을 돌면서 가장긴 연속적인 부분을 찾는다.

import sys

n = int(input())
d=[[0]*6 for _ in range(n)]
for i in range(n):  # dp 테이블에 입력값 넣기
    a,b = map(int,sys.stdin.readline().split())
    d[i][a]+=1
    d[i][b]+=1
max_student=0 # 최대 학생수
grade=0 # 최대 학생수가 나오는 그레이드
for i in range(1,6):  # 각 그레이드 별로 돌기
    temp_std=0  #임시로 받아둘 학생수
    temp_grade=i #임시 그레이드
    for j in range(n):  # 연속적인 책상을 찾기위한 for문
        if d[j][i]: #해당 책상에 그레이드가 존재하면 학생수 증가
            temp_std+=1 
        else:   # 그 책상에 있는 학생 중 해당 그레이드가 없으면 갱신해왔던 임시 학생수 비교
            if max_student<temp_std:
                max_student=temp_std
                grade=temp_grade
            temp_std=0 
    else:
          if max_student<temp_std:
              max_student=temp_std
              grade=temp_grade
          temp_std=0

print(max_student,grade)


# 풀이시간 40분
# 메모리 43300kb 시간 244ms 