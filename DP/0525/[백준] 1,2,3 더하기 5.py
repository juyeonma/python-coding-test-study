# 첫번째 for문에 원래 %를 쓰지 않았는데 시간초과가 자꾸 났다. 이유가 뭘까?
# 연산차이일 뿐이라고 생각했는데 숫자가 커질수록 시간도 오래걸리는 건가?

# 1차원 배열로 구하는 방법을 생각해봤었는데 아무리 생각해도 점화식이 구해지지 않았다.
# 나열해봐도 규칙이 발견이 안돼서 포기할까 싶었는데 관점을 바꿨더니 풀렸다.
# 1씩 증가하면서 그 수가 만들어질 수있는 경우에서 끝숫자가 1,2,3으로 나눠서 구하는 게 포인트였다
# 그러면 그 다움수에서 그 이전수의 같은 위치를 제외한 나머지 위치의 개수만큼만 더해주면 된다 
# d[n] = [d[i-1][1]+d[i-1][2], d[i-2][0]+d[i-2][2],  d[i-3][0]+d[i-3][1]] 

import sys
n = int(sys.stdin.readline())
d=[[0,0,0] for _ in range(100000)]
d[0]=[1,0,0]
d[1]=[0,1,0]
d[2]=[1,1,1]

for i in range(3,100000):
    d[i]=[(sum(d[i-1][1:]))%1000000009,(sum(d[i-2])-d[i-2][1])%1000000009, (sum(d[i-3][:2]))%1000000009]

for _ in range(n):
    k=int(sys.stdin.readline())
    print(sum(d[k-1])%1000000009)

#풀이시간 1시간
# 51492kb 160ms