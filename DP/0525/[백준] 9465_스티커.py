# 전에 풀어본 문제라서 비교적 쉽게 풀었다. 이 전에 풀때는 이해를 잘못했는데 dp 실력이 조금 오른 모양인지 이해가 갔다.
# 이 문제는 d[n]으로 풀 수 없다 왜냐하면 d[n+1]의 최대값이 d[n]에서 사용했던 스티커를 거쳐서 온다는 보장이 없기 때문이다
# 문제 설명에도 나오듯이 하나의 열을 뛰어 넘고 최대값이 되는 경우도 있고, 다른 경우를 생각해보면 반대 스티커를 통해서 다음 스티커의 최대값이 결정되는 경우도 있다.
#그렇기 떄문에 2중배열을 이용해서 두가지 경우를모두 구하면서 넘어가야한다.
# d[0][n] = max(d[1][n-2],d[1][n-1]) + stk[0][n]
# d[1][n] = max(d[0][n-2],d[0][n-1]) + stk[1][n]
# 최대가 되는 경우는 그 이전 반대쪽 최대값을 통해서 될 수도 있고, 이전이전의 최대값을 통해서 될 수도 있기 때문에 위와 같은 점화식이 나왔다.

t = int(input())

def test():
    n = int(input())
    stk = [list(map(int,input().split())) for _ in range(2)]
    if n>1: # n-2까지 알아야하므로 2인 경우는 초기값구하듯이 구한다
        stk[0][1]+=stk[1][0]
        stk[1][1]+=stk[0][0]
    for i in range(2,n):  #2 이상인 경우는 점화식을 이용해서 구할 수 있기 때문에 그냥 구한다.
        stk[0][i]+=max(stk[1][i-1],stk[1][i-2])
        stk[1][i]+=max(stk[0][i-1],stk[0][i-2])
    return max(stk[0][-1],stk[1][-1]) 

for _ in range(t):
    print(test())

# 풀이시간 15분
# 메모리 41008kb 시간 584ms