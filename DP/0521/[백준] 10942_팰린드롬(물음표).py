# 처음 시간초과
# 이 문제는 input()으로 입력을 받으면 시간초과가 나는 것 같다.
#질문의 개수가 너무 커서 질문의 캐수는 n^2이 되면 안된다 질문의 개수는 한번만 돌아야한다.
# 수열의 크기는 2000이 최대이므로 n^2까지는 충분하다.
# O(n^2+m)으로 답을 내야한다.
# 수열을 for문 두개로 돌면서 슬라이싱을 통해 뒤집는 경우와 비교를 하려했지만 슬라이싱도 O(n)이 걸리기 때문에 슬라이싱도 하면안된다
# 그래서 고민을 하다가 대칭이라는 점을 생각해서 각 수열의 요소를 차례로 돌면서 중간위치로 그 요소를 지정하고 양쪽에 숫자를 비교하는 방식으로 풀었다.
# 이렇게 되면 그 양쪽의 숫자가 달라지는 시점부터는 무조건 팰린드롬수가 안되기때문에 탈출하면 된다.
# 이렇게 풀면 이론상 O(n*n/2) 이정도 걸리고 일반적으로는 다 돌기전에 break가 되는 경우가 있을 거기 때문에 그 안에 완료된다.
# 근데 이 풀이가 dp인걸까.. 부분합느낌으로 푼거같다 부분합도 어떻게 보면 dp느낌이 나는 것 같기도 하고..

# 점화식==dp 가 아니라고 봐야되는 건가?
# dp는 작은 문제를 해결해서 큰 문제를 해결하는 알고리즘이고, 이 문제도 dp테이블을 채워가면서 답을 내는 것이니 dp라고 생각해야겠다


#메모리 250420KB 시간 2284ms
# 메모리가 왜이렇게 클까?..
# d[0][j]를 안써는데도 비워두고 해서 그런가 해서 인덱스0부터 사용해봤는데 오히려 메모리가 증가했다...
import sys

def main():
    n = int(input())
    n_list = list(map(int,sys.stdin.readline().rstrip().split()))
    m = int(input())
    m_list = [list(map(int,sys.stdin.readline().rstrip().split())) for _ in range(m)]
    d=[[0]*(n+1) for _ in range(n+1)] # d[1][3]은 수열 1부터 3까지의 위치에서 팰린드롬인지 판단 0이면 x 1이면 팰린드롬
    
    def check(st,en):
      while st>0 and en<=n:   # st가 1보다 작아지거나 en이 요소의 끝보다 커지면 탈출
        if n_list[st-1]==n_list[en-1]:  # 가운데 값부터 왼쪽으로 오른쪽으로 늘려가면서 비교
            d[st][en]=1
        else: # 한번이라도 팰린드롬이 아니면 그 이후는 무조건 아니므로 탈출
            break
        st-=1
        en+=1
    
    for i in range(1,n+1):  # 1에 첫번째 요소를 담기 때문에 1부터 했다. i는 가운데 값을 의미한다
      st=i  
      en=i
      check(st,en)    # st는 1씩 줄고  en은 1씩 늘어나는데 여기서는 홀수개일 경우를 계산
      check(st,en+1)  #여기서는 짝수 개일 경우를 계산

    for (s,e) in m_list:  # dp 테이블이 완성되었고 출력하기
      print(d[s][e])

main()