'''
# 백준_16987_계란으로-계란치기. 골드 5. 풀이: 23.07.18

# How to
- 계란: 내구도, 무게
- 내구도는 상대 계란의 무게만큼 감소

- 인덱스가 증가하는 순서는 고정적인데, 깨지지 않은 계란 중에서 하나를 고르는건 각기 다르다.
- 즉, dfs
    - 매번 종료 조건에 따라 출력하거나 최댓값을 갱신한다.
    - 현재 인덱스의 계란이 깨졌다면, 바로 그 다음 인덱스의 계란을 손에 든다(재귀)
    - 현재 인덱스의 계란이 깨지지 않았다면, 다른 계란들과 부딪히고 재귀로 들어간다.
        - 이때 무조건 그 다음 인덱스의 계란으로 들어간다.
    - 재귀 앞뒤로 계란의 내구도를 감소한 후 깨진 계란의 수를 세고, 다시 계란의 내구도를 복구한다.
    
- 재귀 종료 조건
    - 모든 계란이 깨진 경우 -> 바로 개수 출력하고 종료
    - 모든 계란을 탐색한 경우(즉, 인덱스 범위를 벗어난 경우) -> 최댓값 갱신
    - 현재 계란 빼고 나머지 다 깨진 경우(더 재귀가 깊어져도 계란을 부딪힐 수 없다.) -> 최댓값 갱신
    

# Review
- 풀이 시간: 30분
- 재귀 종료조건이 관건이었다.
    - 처음에 현재 계란 빼고 다 깨진 경우를 캐치하지 못해서 헤맸다.
    - 이 부분을 따로 조건문 나눠서 answer = cnt로 했는데, 시간이 쪼금 늘어나긴 했다. 근데 조건문 너무 많아진듯..
'''

# Code
# 1. 성공
## 메모리: 31256 KB, 시간: 3660 ms
import sys
input = sys.stdin.readline

n = int(input())
# 내구도 s, 무게 w
eggs = [list(map(int, input().split())) for _ in range(n)]

answer = 0

def dfs(idx, eggs, cnt):
    global answer

    # 모든 계란이 깨진 경우, 계란 개수를 출력하고 종료
    if cnt == n:
        print(n)
        sys.exit(0)
        
    # 모든 계란을 탐색했거나, 현재 계란 빼고 다 깨진 경우, 최댓값 갱신하고 return
    if idx == n or cnt == n-1:
        answer = max(answer, cnt)
        return
    
    # 현재 손에 든 계란이 깨진 경우, 내려놓고 3번으로 넘어감
    if eggs[idx][0] <= 0:
        dfs(idx+1, eggs, cnt)
        return
    
    # 현재 손에 든 계란이 깨지지 않은 경우, 다른 계란과 부딪히고 3번으로 넘어감.
    for i in range(n):
        # 남은 계란 중 깨지지 않은 계란일 경우
        if i != idx and eggs[i][0] > 0:
            # 계란을 부딪히고, 내구소 감소
            eggs[idx][0] -= eggs[i][1]
            eggs[i][0] -= eggs[idx][1]
            
            # 부딪힌 결과, 몇개나 깨졌을까?
            tmp = 0
            if eggs[idx][0] <= 0:
                tmp += 1
                
            if eggs[i][0] <= 0:
                tmp += 1
            
            # 그 다음 계란을 손에 든다.
            dfs(idx+1, eggs, cnt+tmp)
            
            # 계란을 부딪히기 전으로 원상복구
            eggs[idx][0] += eggs[i][1]
            eggs[i][0] += eggs[idx][1]
            
        
    
# 가장 왼쪽의 계란을 든다
dfs(0, eggs, 0)

print(answer)