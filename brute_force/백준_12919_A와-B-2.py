'''
# 백준_12919_A와 B 2. 골드 5. 풀이: 23.04.29

# 풀이방법
- 조건
    1. 문자열 뒤에 A 추가
    2. 문자열 뒤에 B 추가하고, 문자열 뒤집음
- 방법
    - S->T 를 묻고있지만, 거꾸로 T에서 A로 바꿔보자. 추가하는 것보다 제거하는 것이 더 경우의 수가 적다.
    - 1. 뒤에 A를 지우거나, 2. 뒤집고 B를 지우거나.
    - S와 같으면, 1 출력 후 바로 프로그램 종료
        - sys.exit(0): 성공적으로 프로그램 종료시킴.
    - S와 같지 않다면, 함수를 return 한 후 0 출력.
- 예제
BABA -> BAB (A 제거) -> BAB, BA (뒤집고, B 제거)-> AB, A (뒤집고, B 제거)
'''

'''
# 피드백
- 엄청 쉬운 문제였다. 
- 다만, 여러가지 실험을 해봤는데.. 워낙 시간 복잡도가 낮은 코드라, 큰 차이를 못 느낌.
    - 1. input은 list와 str중 어느것이 빠를까?
    - 2. 0 인덱스 빼고 뒤집을때, t[:0:-1]와 t[1:][::-1] 중 어느것이 빠를까?
- 성공 조건을 찾으면 바로 함수를 종료할 때는 return 대신에 sys.exit(0)이 유용하다는거 잊지말기!!
'''
# code
import sys

s = input()
t = input()

def dfs(t):
    # S와 같으면, 1 출력 후 바로 프로그램 종료
    if t == s:
        print(1)
        sys.exit(0)
        
    # 더이상 탐색 불가. return
    if len(t) == 0:
        return
    
    # 1. 뒤에 A를 지우거나
    if t[-1] == 'A':
        dfs(t[:-1])
    
    # 2. 뒤집고 B를 지우거나.(즉, 0번쨰 index를 제외하고 뒤집음)
    if t[0] == 'B':
        dfs(t[:0:-1])

dfs(t)

# S와 같지 않다면, 함수를 return 한 후 0 출력.
print(0)
'''
# 결과
메모리: 31256 KB
시간: 40 ms
코드 길이: 254 B
'''