'''
# 백준_16953_A → B. 실버 2. 풀이: 23.05.29

# How to
- a -> b로 가는 횟수를 물었지만, 거꾸로 b -> a로 가겠다.
    - b -> a로 가는 것이 경우의 수를 줄이면서 더 작은 수로 수렴하기 때문.
- 끝이 1이면 1을 빼고, 짝수면 나눈다.
    
    
## 예제
100 -> 40021
: 40021 -> 4002 -> 2001 -> 200 -> 100

2 162
: 162 -> 81 -> 8 -> 4 -> 2

# Review
- 바로 성공하긴 했지만, 매번 a 와 b를 비교하고, 홀수 여부를 체크하는게 번거로웠다. 코드도 안 이쁘고..
- 그래서 맞힌 사람을 보니, 훨씬 코드도 이쁘고 깔끔했다!
    - 반복문의 조건을 a < b로 해놓고, 반복문이 끝난 이후에 a와 b를 비교하더라.
- 끝에 1을 어떻게 뺄지 고민하다가, 문자열에서 뺐는데, 그냥 10을 나눴을 때 나머지가 1인 경우에 10을 나눴을 때 몫을 구하는게 더 심플했다!
'''

# 성공 Code
a, b = input().split()

answer = 1
while True:
    # b가 a가 되었으므로, 성공
    if a == b:
        print(answer)
        break
    
    # 1을 제외한 홀수라면, 나누거나 1을 뺄 수 없으므로 실패
    # b가 1이라면, a와 같아지지 못했으므로 실패
    elif b[-1] in ['3', '5', '7', '9'] or b == '1':
        print(-1)
        break
    
    # 끝이 1이라면, 1을 빼자
    if b[-1] == '1':
        b = b[:-1]
        
    # 2로 나누자
    else:
        b = str(int(b)//2)

    # 횟수 +1
    answer += 1
        
        
# 맞힌 사람에서 깔끔한 코드: 40 ms
a, b = map(int, input().split())
answer = 1  

while a < b:
    # 끝이 1이라면, 1을 빼자
    if b % 10 == 1:
        b = b // 10
    # 2로 나누자
    else:
        b = b / 2
    answer += 1

if a == b:
    print(answer)
else:
    print(-1)

        
'''
# Result
풀이 시간: 10분
메모리: 31256 KB
시간: 44 ms
코드 길이: 285 B
'''