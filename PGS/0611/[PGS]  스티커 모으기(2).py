#아이디어는 금방 떠올리긴 했는데 구현의 늪에 빠졌다..

# 맨앞의 스티커를 뗄 경우와 떼지 않을 경우를 나눠서 구했다.
# 뗀 경우는 d1 떼지 않은 경우는 d2이다
# 뗀 경우의 점화식은 d[n] = max(d[n-2],d[n-3])+sticker[n-1] 로 설정하였다.
# 이 점화식의 경우에는 맨앞은 떼고 맨뒤에서 두번째는 떼는 경우를 점화식으로 만든것이다
# 뭔가 나만 이해할 수 있는 방식으로 푼 것 같은데 옛날에 풀었던 계단 오르기처럼 풀었다.
# 설명해보쟈면 맨 뒤에서 두번째 스티커는 뗀다고 가정하고 d[n]을 구한 것이다.
# 이렇게하면 마지막에서 두번째는 무조건 떼기 때문에 최대값을 구할 때 문제가 생기기 때문에 d[n]과 d[n-1]을 모두 비교한다.
# 왜나하면 d[n]은 n-1번째 스티커를 뗀것이고  d[n-1]은 n-2번째 스티커를 뗀것이기 때문에 d[n-1]은 n-1번째 스티커는 안뗀것이 된다
# 그래서 모든 경우를 포함하게 되어 두 가지 경우를 비교하면 최대값을 도출할 수 있다.
# 점화식 원리는 d[n-2]는 n-3을 뗀상태이고 n-2를 안떼고 n-1을 뗀 경우 
# d[n-3]은 n-4는 뗀 상태이고 n-3와n-2을 안뗀 상태이고 n-1을 뗀 경우이다
# 그러니까 두칸을 건너뛰고 떼는 경우와 한칸을 건너뛰고 떼는 경우를 구한 것이다


# 맨앞을 떼지 않은 경우도 원리가 똑같다
# dp 배열 마지막것 두개를 비교해야되다보니 if문으로 길이가 1일때는 예외로 구해줘야한다.

# 그런데 이렇게 풀면 초항 구하기가 쉽지 않은 것 같아서 좋은 풀이는 아닌 것같다


# dp는 여러가지 방식으로 풀 수 있다는 것을 다시 한번 알았고, 미숙하다보니 최적화된 풀이는 아니었던 것 같다
# 풀 수 있을 것 같아서 오랜시간을 잡고 풀긴 했는데 풀었다는것에 일단 의의를 둬야겠다
# 정석풀이를 이해하고 나니 내 풀이는 보고 싶지 않아졌다..

def solution(sticker):
    if len(sticker)==1:
        return sticker[0]
    
    d1=[sticker[0]]
    if len(sticker)>1:
        d1.append(sticker[0])
    if len(sticker)>2:
        d1.append(sticker[0])
    if len(sticker)>3:
        d1.append(sticker[0]+sticker[2])
    if len(sticker)>4:
        d1.append(sticker[0]+sticker[3])
    for i in range(5,len(sticker)):
        d1.append(max(d1[i-2],d1[i-3])+sticker[i-1])
    
    d2=[0]
    if len(sticker)>1:
        d2.append(sticker[1])
    if len(sticker)>2:
        d2.append(sticker[2])
    if len(sticker)>3:
        d2.append(sticker[1]+sticker[3])
    for i in range(4,len(sticker)):
        d2.append(max(d2[i-2],d2[i-3])+sticker[i])

    answer= max(d1[-1],d1[-2],d2[-1],d2[-2])
    return answer

#걸린시간: 시간 재다가 현타와서 멈추긴 했는데 2시간 반정도 걸린 것 같다..

# 최적화 풀이
# 검색했을 때 나온 풀이를 보고 다시 푼 풀이인데 검색했을 때 나온 풀이는 뭔가 이상하다
# 첫번째 스티커를 뜯는 경우에서 예제1을 예시로 들어보면 [14,14,19....]가 된다
# for문을 range(2,)로 해서 그런 것 같은데 그럼에도 답은 맞춰진다 납득이 잘안간다

# 아래풀이는 첫번째 스티커를 뜯은 경우와 안 뜯은 경우를 나눈 것은 같은데
# 4개의 스티커가 만들어진 순간부터 for문을 돌렸다. 그래야 예외 없이 가능하다
# 논리는 첫번째 스티커를 뜯은 경우
# d[n] = n개의 스티커가 있을 때 최대수 이다
# 그렇다면 d[n] = max(d[n-1],d[n-2]+sticker[n-1])이다
# d[n-1]은 n-1이 뜯어지지 않은 상태는 확정이고 그 상태에서 최대값이다
# 두 개의 스티커를 연속으로 안뜯은 경우가 최대가 될 수있기 때문에 d[n-1]을 후보에 올리고
# d[n-2]+sticker[n-1]은 n-2가 뜯어지지 않은 상태가 확정이고 그 상태에서 최대값이다
# 이상태에서는 무조건 n-1의 스티커를 뜯는 경우르 더하는게 최대값이므로 이것도 후보에 넣는다
# 즉 맨 마지막 하나를 안뜯거나 두개를 안뜯는 경우의 최대값을 구하는 것이다
# 첫번째스티커를 안뗀 경우도 같은 논리이다
# d[n] = max(d[n-1], d[n-2]+sticker[i])인데
# d[n-1]은 맨 마지막 것이 떼어졌는지 안떼어졌는지 모른다 그렇기에 그 뒤에 스티커를 붙일 수없다
# 만약 떼어진 상태로 최대값이라면 스티커를 붙일 수 없지만 떼어지지 않은 상태라면 d[n-2]와 같다
# 왜 같냐면 떼어지지 않앗다면 없다고 생각하고 비교해보면 이해할 수있다.
# d[n-2]와 같은 상태라면 어차피 이것은 d[n-2]+sticker[i]에서 max 값 비교로 걸러지기때문에 신경 쓸 필요없다

# 이렇게 두가지 경우를 고려해야된다고 생각해서 처음에 이중배열로 풀었다가 포기했다. 하지만 될 것 같기도하다
# 이렇게 갈라지는 경우라도 깊게 생각해보면 굳이 이중배열을 안써도 된다는 것을 알았다.
def solution(sticker):
    d1=[sticker[0],sticker[0],sticker[0]]
    d2=[0,sum(sticker[:2])-sticker[0]]

    if len(sticker)>2:
        d2.append(max(sticker[1:3]))

    for i in range(3,len(sticker)):
        d1.append(max(d1[i-1],d1[i-2]+sticker[i-1]))
        d2.append(max(d2[i-1],d2[i-2]+sticker[i]))

    return max(d1[-1],d2[-1])