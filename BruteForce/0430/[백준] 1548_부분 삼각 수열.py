# 못풀었다..
# A[start]+A[start+1]> A[end] 이 부분에서 왜 start와 start+1으로 같이 올라가면서 비교해야되는지 이해가 안갔다.
# 굳이 그렇게 안풀고 모든 경우를 다 겪어보며 풀어봐도 되지만 위 방식이 효율적인다.
# 왜냐하면 예제 입력 2의 예시를 보면 
# 7
# 2 3 4 1 3 4 5 이다
# 삼각 수열이 되는 조건으로는 가장 작은 숫자 두개가 가장 큰 숫자 하나보다 크다면 다른 조건은 무조건 만족한다.
# 왜냐하면 가장 큰 숫자가 끼여 있다면 무조건 그 합은 나머지 하나의 값보다 크기 때문이다.

# 가장 작은 값과 큰값을 구해야한다는 논리를 보면 차례대로 올라가면서 풀어야 효율적이기 때문에 정렬이 필요하다는 것을 알 수 있다.
# 1 2 3 3 4 4 5
# 여기서 의문이 든 논리가 A[0]+A[1]>A[2] ~ A[0]+A[1]>A[-1]까지해보고나서 A[0]+A[2] 가아니라 A[1]+A[2]로 가는 이유가 궁금했다
# 생각해본 결과 작은 값을 증가시켜서 비교할때  하나를 증가시키는 것보다 두개를 다 증가시키는 것이 값이 더커지기 때문에 더 길이가 길다
# 때문에 굳이 하나만 증가시킬필요없이 두개가 함께 움직이는 것이 더 효율적이다.
# 또한 어차피 움직이는것은 가장큰 값이므로 작은값 두개의 위치는 상관이 없다는 것도 위 논리를 뒷받침해주는 근거이다. 

N = int(input())
A = sorted(list(map(int,input().split())))

if N>2:   # N=1 or N=2 인 경우 N값을 출력해야 한다는 것은 5번을 통해 알 수 있다.
    result=2  # 예제 1처럼 두 개만 될 경우 
    for start in range(N-2):  #첫번째인덱스는 마지막위치가 뒤에서 두번째이기때문에
        end=start+2 
        while end<N:  #가장 큰 값의 인덱스가 끝에 닿기 전까지 반복
            if A[start]+A[start+1]<=A[end]: # 삼각 수열 조건에 맞지 않으면 탈출
                break
            end+=1   # 삼각 수열 조건에 맞을 경우 다음큰 수 확인
        result=max(result,end-start)  # while문 탈출하고나서 최대 길이 비교
    print(result)
else:
    print(N)
